








































1. Write a Lex program to count the number of lines and characters in the input file.

%{
int line_count = 0;
int char_count = 0;
%}

%%

\n      { line_count++; char_count++; }
.       { char_count++; }

%%

int main() {
    yylex();
    printf("Total Lines: %d\n", line_count);
    printf("Total Characters: %d\n", char_count);
    return 0;
}

int yywrap() {
    return 1;
}


2. Lex program to count the number of vowels and consonants in a given string

%{
int vowels = 0;
int consonants = 0;
%}

%%

[aeiouAEIOU]      { vowels++; }
[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]   { consonants++; }
.                { /* ignore anything else */ }

%%

int main() {
    yylex();
    printf("Vowels: %d\n", vowels);
    printf("Consonants: %d\n", consonants);
    return 0;
}

int yywrap() {
    return 1;
}




3. Write a Lex program that implements the Caesar cipher: it replaces every letter
with the one three letters after in in alphabetical order, wrapping around at Z. e.g.
a is replaced by d, b by e, and so on z by c.

%{
#include <stdio.h>
%}

%%
[a-z] {
    char c = yytext[0];
    c = ((c - 'a' + 3) % 26) + 'a';
    putchar(c);
}

[A-Z] {
    char c = yytext[0];
    c = ((c - 'A' + 3) % 26) + 'A';
    putchar(c);
}

.      { putchar(yytext[0]); }

%%

int main() {
    yylex();
    return 0;
}

int yywrap() {
    return 1;
}




4. Write a Lex program that finds the longest word (defined as a contiguous string
of upper and lower case letters) in the input.


%{
#include <stdio.h>
#include <string.h>

char longest[1000] = "";
%}

%%
[A-Za-z]+  {
                if (strlen(yytext) > strlen(longest)) {
                    strcpy(longest, yytext);
                }
            }

.|\n        ;

%%

int main() {
    yylex();
    printf("Longest word: %s\n", longest);
    return 0;
}



5. Write a Lex program that distinguishes keywords, integers, floats, identifiers,
operators, and comments in any simple programming language.


%{
#include <stdio.h>
#include <string.h>

int isKeyword(char *word) {
    const char *keywords[] = {
        "int","float","if","else","while","for","return","char","double","long","short","void"
    };
    int n = sizeof(keywords)/sizeof(keywords[0]);
    for (int i = 0; i < n; i++) {
        if (strcmp(keywords[i], word) == 0)
            return 1;
    }
    return 0;
}
%}

%%
"//".*                          { printf("Comment: %s\n", yytext); }

"/*"([^*]|\*+[^*/])*\*+"/"      { printf("Comment: %s\n", yytext); }

[0-9]+"."[0-9]+                 { printf("Float: %s\n", yytext); }

[0-9]+                          { printf("Integer: %s\n", yytext); }

[A-Za-z_][A-Za-z0-9_]*          {
                                    if (isKeyword(yytext))
                                        printf("Keyword: %s\n", yytext);
                                    else
                                        printf("Identifier: %s\n", yytext);
                                }

"=="|"!="|"<="|">="|"="|"+"|"-"|"*"|"/"|"<"|">"   {
                                    printf("Operator: %s\n", yytext);
                                }

[ \t\n]+                        { /* ignore whitespace */ }

.                               { printf("Unknown token: %s\n", yytext); }
%%

int yywrap() { return 1; }

int main() {
    yylex();
    return 0;
}




6. Write a Lex program to count the number of words, characters, blank spaces and
lines in a C file.


%{
#include <stdio.h>

int words = 0, chars = 0, spaces = 0, lines = 0;
%}

%%
[ \t]+          { spaces += yyleng; chars += yyleng; }
\n              { lines++; chars++; }
[A-Za-z0-9_]+   { words++; chars += yyleng; }
.               { chars++; } 
%%

int yywrap() { return 1; }

int main() {
    yylex();
    printf("\nNumber of characters: %d\n", chars);
    printf("Number of words     : %d\n", words);
    printf("Number of spaces    : %d\n", spaces);
    printf("Number of lines     : %d\n", lines);
    return 0;
}




7. Write a Lex specification program that generates a C program which takes a
string “abcd” and prints the following output:
abcd
abc
ab
a


%{
#include <stdio.h>
%}

%%
.   {
        char str[] = "abcd";
        for (int i = 4; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                printf("%c", str[j]);
            }
            printf("\n");
        }
        exit(0);
    }
%%

int main() {
    yylex();
    return 0;
}




8. A program in Lex to recognize a valid arithmetic expression.


%{
#include <stdio.h>
#include <ctype.h>

int paren_count = 0;   // To track parentheses
int valid = 1;         // Assume valid unless found invalid
%}

%%
[0-9]+                 ;         // integer
[\+\-\*\/]             ;         // operators
"("                    { paren_count++; }
")"                    { paren_count--; if (paren_count < 0) valid = 0; }
[ \t\n]+               ;         // whitespace ignored

.                      { valid = 0; }   // any other character → invalid
%%

int yywrap() { return 1; }

int main() {
    printf("Enter an arithmetic expression:\n");
    yylex();

    if (valid && paren_count == 0)
        printf("Valid arithmetic expression\n");
    else
        printf("Invalid arithmetic expression\n");

    return 0;
}




9. Write a YACC program to find the validity of a given expression (for operators + -
* and /)A program in YACC which recognizes a valid variable which starts with
letter followed by a digit. The letter should be in lowercase only.

expr.l

%{
#include "y.tab.h"
%}

%%

[0-9]+      { return NUM; }
[\+\-\*\/]  { return yytext[0]; }
[ \t\n]+    ;        // ignore whitespace
.           { return yytext[0]; }

%%

int yywrap() { return 1; }
 


expr.y

%{
#include <stdio.h>
#include <stdlib.h>

int yylex();
void yyerror(const char *s);
%}

%token NUM

%%

E : E '+' E
  | E '-' E
  | E '*' E
  | E '/' E
  | '(' E ')'
  | NUM
  ;

%%

void yyerror(const char *s) {
    printf("Invalid Expression\n");
}

int main() {
    printf("Enter expression:\n");
    if (yyparse() == 0)
        printf("Valid Expression\n");
    return 0;
}


var.l


%{
#include "y.tab.h"
%}

%%

[a-z][0-9]      { return VAR; }
.*              { return INVALID; }

%%

int yywrap(){ return 1; }



var.y
%{
#include <stdio.h>
#include <stdlib.h>

int yylex();
void yyerror(const char *s);
%}

%token VAR INVALID

%%

S : VAR      { printf("Valid Variable\n"); }
  | INVALID  { printf("Invalid Variable\n"); }
  ;

%%

void yyerror(const char *s) {
    printf("Invalid Variable\n");
}

int main() {
    printf("Enter variable:\n");
    yyparse();
    return 0;
}



10. A Program in YACC to evaluate an expression (simple calculator program for
addition and subtraction, multiplication, division).

l file
%{
#include "y.tab.h"
%}

%%

[0-9]+      { yylval = atoi(yytext); return NUMBER; }
[ \t\n]+    ;        /* ignore whitespace */

"+"         return PLUS;
"-"         return MINUS;
"*"         return MUL;
"/"         return DIV;
"("         return '(';
")"         return ')';

.           return yytext[0];

%%


y file 

%{
#include <stdio.h>
#include <stdlib.h>
%}

%token NUMBER
%token PLUS MINUS MUL DIV

%left PLUS MINUS        /* lowest precedence */
%left MUL DIV           /* higher precedence */

%%

start: expr   { printf("Result = %d\n", $1); }
     ;

expr: expr PLUS expr   { $$ = $1 + $3; }
    | expr MINUS expr  { $$ = $1 - $3; }
    | expr MUL expr    { $$ = $1 * $3; }
    | expr DIV expr    { 
                            if($3 == 0){
                                printf("Error: Division by zero\n");
                                exit(1);
                            }
                            $$ = $1 / $3;
                        }
    | '(' expr ')'      { $$ = $2; }
    | NUMBER            { $$ = $1; }
    ;

%%

int main() {
    printf("Enter expression: ");
    yyparse();
    return 0;
}

int yyerror(char *s) {
    printf("Invalid expression\n");
    return 0;
}




11. Program in YACC to recognize the string „abbb‟, „ab‟ „a‟ of the langauge (an b
n , n>=1).


l file
%{
#include "y.tab.h"
%}

%%

"a"     return A;
"b"     return B;
[ \t\n] ;
.       return yytext[0];

%%



y file

%{
#include <stdio.h>
#include <stdlib.h>

int valid = 1;
%}

%token A B

%%

S : A S B       /* recursive rule for a^n b^n */
  | A B         /* base case: ab */
  ;

%%

int main() {
    if (yyparse() == 0 && valid)
        printf("VALID string (a^n b^n)\n");
    else
        printf("INVALID string\n");
    return 0;
}

int yyerror(char *s) {
    valid = 0;
    return 0;
}




12. Program in YACC to recognize the language (an b , n>=10). (output to say input
is valid or not)


l file

%{
#include "y.tab.h"
%}

%%

"a"     return A;
"b"     return B;
[ \t\n] ;         /* ignore */
.       return yytext[0];

%%



y file 
%{
#include <stdio.h>
#include <stdlib.h>

int countA = 0;
int seenB = 0;
int valid = 1;
%}

%token A B

%%

S : A_seq B {
                if (countA >= 10 && seenB == 1)
                    valid = 1;
                else
                    valid = 0;
            }
  ;

A_seq : A A_seq   { countA++; }
      | A         { countA++; }
      ;

B : B { seenB++; }
  |   { /* should never come here */ }
  ;

%%

int main() {
    yyparse();
    if (valid)
        printf("VALID string (a^n b, n>=10)\n");
    else
        printf("INVALID string\n");
    return 0;
}

int yyerror(char *s) {
    valid = 0;
    return 0;
}



























