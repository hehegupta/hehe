g++ -fopenmp -o program program.cpp

1. matrix matrix
#include <iostream>
#include <vector>
#include <omp.h>
#define N 500

int main() {
    std::vector<std::vector<int>> A(N, std::vector<int>(N));
    std::vector<std::vector<int>> B(N, std::vector<int>(N));
    std::vector<std::vector<int>> C(N, std::vector<int>(N, 0));

    // Initialize A and B
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++) {
            A[i][j] = i + j;
            B[i][j] = i - j;
        }

    // Matrix multiplication
    #pragma omp parallel for collapse(2)
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            for (int k = 0; k < N; k++)
                C[i][j] += A[i][k] * B[k][j];

    std::cout << "C[0][0] = " << C[0][0] << "\n";
    return 0;
}



2. histogram
#include <iostream>
#include <vector>
#include <omp.h>
#define SIZE 100000
#define RANGE 100

int main() {
    std::vector<int> data(SIZE);
    std::vector<int> histogram(RANGE, 0);
    int num_threads = omp_get_max_threads();
    std::vector<std::vector<int>> local_hist(num_threads, std::vector<int>(RANGE, 0));

    // Initialize data
    for (int i = 0; i < SIZE; ++i)
        data[i] = i % RANGE;

    #pragma omp parallel
    {
        int tid = omp_get_thread_num();

        #pragma omp for
        for (int i = 0; i < SIZE; ++i)
            local_hist[tid][data[i]]++;

        #pragma omp for
        for (int i = 0; i < RANGE; ++i) {
            for (int t = 0; t < num_threads; ++t)
                histogram[i] += local_hist[t][i];
        }
    }

    std::cout << "Histogram[0] = " << histogram[0] << "\n";
    return 0;
}


3.bfs
#include <iostream>
#include <vector>
#include <queue>
#include <omp.h>

#define V 6

int graph[V][V] = {
    {0,1,1,0,0,0},
    {1,0,1,1,0,0},
    {1,1,0,0,1,0},
    {0,1,0,0,1,1},
    {0,0,1,1,0,1},
    {0,0,0,1,1,0}
};

int main() {
    std::vector<int> visited(V, 0);
    std::queue<int> q;

    visited[0] = 1;
    q.push(0);

    while (!q.empty()) {
        int level_size = q.size();
        std::vector<int> current_level;

        while (level_size--) {
            current_level.push_back(q.front());
            q.pop();
        }

        #pragma omp parallel for
        for (int i = 0; i < current_level.size(); ++i) {
            int node = current_level[i];
            for (int j = 0; j < V; ++j) {
                if (graph[node][j] && !visited[j]) {
                    #pragma omp critical
                    {
                        if (!visited[j]) {
                            visited[j] = 1;
                            q.push(j);
                        }
                    }
                }
            }
        }
    }

    for (int i = 0; i < V; i++)
        std::cout << "Node " << i << " visited: " << visited[i] << "\n";

    return 0;
}


4. Dijkstra
#include <iostream>
#include <vector>
#include <limits>
#include <omp.h>

#define V 6
#define INF 99999

int minDistance(const std::vector<int>& dist, const std::vector<bool>& visited) {
    int min = INF, min_index = -1;
    #pragma omp parallel
    {
        int local_min = INF, local_index = -1;
        #pragma omp for nowait
        for (int v = 0; v < V; ++v) {
            if (!visited[v] && dist[v] < local_min) {
                local_min = dist[v];
                local_index = v;
            }
        }
        #pragma omp critical
        {
            if (local_min < min) {
                min = local_min;
                min_index = local_index;
            }
        }
    }
    return min_index;
}

void dijkstra(int graph[V][V], int src) {
    std::vector<int> dist(V, INF);
    std::vector<bool> visited(V, false);

    dist[src] = 0;

    for (int count = 0; count < V - 1; ++count) {
        int u = minDistance(dist, visited);
        visited[u] = true;

        #pragma omp parallel for
        for (int v = 0; v < V; ++v)
            if (!visited[v] && graph[u][v] && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }

    for (int i = 0; i < V; ++i)
        std::cout << "Distance from " << src << " to " << i << " is " << dist[i] << "\n";
}

int main() {
    int graph[V][V] = {
        {0, 4, 0, 0, 0, 0},
        {4, 0, 8, 0, 0, 0},
        {0, 8, 0, 7, 0, 4},
        {0, 0, 7, 0, 9, 14},
        {0, 0, 0, 9, 0, 10},
        {0, 0, 4, 14, 10, 0}
    };

    dijkstra(graph, 0);
    return 0;
}
