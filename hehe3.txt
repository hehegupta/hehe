#1.casesar


def caesar_cipher_encrypt(text, shift):
    encrypted_text = ""
    for char in text:
        if char.isalpha():  # Check if the character is a letter
            shift_base = ord('A') if char.isupper() else ord('a')
            encrypted_text += chr((ord(char) - shift_base + shift) % 26 + shift_base)
        else:
            encrypted_text += char 
    return encrypted_text


def caesar_cipher_decrypt(text, shift):
    return caesar_cipher_encrypt(text, -shift)  

if __name__ == "__main__":
    message = "Hello, World!"
    shift_key = 3

    encrypted_message = caesar_cipher_encrypt(message, shift_key)
    print(f"Encrypted: {encrypted_message}")

    decrypted_message = caesar_cipher_decrypt(encrypted_message, shift_key)
    print(f"Decrypted: {decrypted_message}")





#2.rail fence

def rail_fence_encrypt(text, key):
 
    rail = [['\n' for _ in range(len(text))] for _ in range(key)]
    

    direction_down = False
    row, col = 0, 0

    for char in text:
        if row == 0 or row == key - 1:
            direction_down = not direction_down
        rail[row][col] = char
        col += 1
        row += 1 if direction_down else -1

    encrypted_text = "".join(char for row in rail for char in row if char != '\n')
    return encrypted_text


def rail_fence_decrypt(cipher, key):
       rail = [['\n' for _ in range(len(cipher))] for _ in range(key)]
    
   
    direction_down = None
    row, col = 0, 0

    for _ in range(len(cipher)):
        if row == 0:
            direction_down = True
        if row == key - 1:
            direction_down = False
        rail[row][col] = '*'
        col += 1
        row += 1 if direction_down else -1

    index = 0
    for i in range(key):
        for j in range(len(cipher)):
            if rail[i][j] == '*' and index < len(cipher):
                rail[i][j] = cipher[index]
                index += 1

    result = []
    row, col = 0, 0
    for _ in range(len(cipher)):
        if row == 0:
            direction_down = True
        if row == key - 1:
            direction_down = False
        if rail[row][col] != '\n':
            result.append(rail[row][col])
            col += 1
        row += 1 if direction_down else -1

    return "".join(result)

if __name__ == "__main__":
    message = "HELLO WORLD"
    key = 3

    encrypted_message = rail_fence_encrypt(message, key)
    print(f"Encrypted: {encrypted_message}")

    decrypted_message = rail_fence_decrypt(encrypted_message, key)
    print(f"Decrypted: {decrypted_message}")





#3.sha
import hashlib

def hash_password_sha256(password):
    
    # Encode the password to bytes, then hash it
    hashed_password = hashlib.sha256(password.encode()).hexdigest()
    return hashed_password

if __name__ == "__main__":
    password = input("Enter a password: ")
    hashed = hash_password_sha256(password)
    print(f"SHA-256 Hashed Password: {hashed}")




#4.HIBP
import hashlib
import requests

def get_sha1_hash(password):
    
    return hashlib.sha1(password.encode('utf-8')).hexdigest().upper()

def check_password_pwned(password):
       sha1_hash = get_sha1_hash(password)
    first5 = sha1_hash[:5]
    tail = sha1_hash[5:]

    # Send the request to HIBP API to get the list of hashes with the same first 5 characters
    url = f'https://api.pwnedpasswords.com/range/{first5}'
    response = requests.get(url)

    if response.status_code == 200:
       
        hashes = response.text.splitlines()
        for hash_entry in hashes:
            hash, count = hash_entry.split(':')
            if hash == tail:
                return True
    return False

def check_passwords_in_file(file_path):
   
    with open(file_path, 'r') as file:
        for line in file:
            username, password = line.strip().split(',')
            if check_password_pwned(password):
                print(f"Password for {username} has been pwned!")
            else:
                print(f"Password for {username} is safe.")

if __name__ == "__main__":
    file_path = 'usernames_passwords.txt' 
    check_passwords_in_file(file_path)




#5.random
import random

def load_dictionary(file_path):
    """
    Loads words from a dictionary file.
    
    :param file_path: Path to the dictionary file
    :return: List of words from the dictionary file
    """
    with open(file_path, 'r') as file:
        # Read the words and strip any extra whitespace
        words = [line.strip() for line in file.readlines()]
    return words

def generate_password(dictionary, num_words=4, add_numbers=True, add_special_chars=True):
    
     selected_words = random.sample(dictionary, num_words)
    
    
    password = ''.join(selected_words).lower()

   
    if add_numbers:
        password += str(random.randint(0, 99))  # Add a random number
    if add_special_chars:
        special_chars = ['!', '@', '#', '$', '%', '&', '*', '(', ')', '_', '-', '+', '=', '?']
        password += random.choice(special_chars)  # Add a random special character
    
    return password


if __name__ == "__main__":
    dictionary_path = 'dictionary.txt'  # Path to your dictionary file
    dictionary_words = load_dictionary(dictionary_path)
    
    # Generate a password with 4 random words, numbers, and special characters
    generated_password = generate_password(dictionary_words, num_words=4)
    
    print(f"Generated Password: {generated_password}")





#6.brute

import itertools
import string

def brute_force_attack(target_password, max_length=4):
    
    characters = string.ascii_lowercase  

 
    for length in range(1, max_length + 1):
        for combo in itertools.product(characters, repeat=length):
           
            guess = ''.join(combo)
            print(f"Trying: {guess}")
            
           
            if guess == target_password:
                print(f"Password found: {guess}")
                return guess
    print("Password not found within the given length limit.")
    return None


if __name__ == "__main__":
    target_password = "abc"  # Set the target password (you can change this)
    max_length = 4  # Set the maximum length for the password combinations
    brute_force_attack(target_password, max_length)

